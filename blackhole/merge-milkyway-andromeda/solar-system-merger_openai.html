<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Solar System Merger — WebGL Simulation (Point Clouds)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  #ui{
    position:fixed;left:12px;top:12px;color:#ddd;font-size:13px;background:rgba(0,0,0,0.45);
    padding:8px 10px;border-radius:8px;backdrop-filter: blur(4px);z-index:20;max-width:42vw;
  }
  #notice{font-size:11px;line-height:1.2;color:#cfcfcf}
  #controls{margin-top:8px;display:flex;gap:8px;align-items:center}
  label{font-size:12px;color:#eee}
  input[type=range]{width:360px}
  canvas{display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<div id="ui">
  <div id="notice">
    This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0). Hosted at https://jrobb.org/space/solar-system-merger.html. Source: https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html
  </div>
  <div id="controls">
    <label for="progress">Loop progress</label>
    <input id="progress" type="range" min="0" max="1" step="0.0002" value="0.0"/>
    <button id="reset">Reset</button>
    <div style="margin-left:8px;font-size:12px;color:#ddd" id="timeLabel">0s</div>
  </div>
</div>

<canvas id="glcanvas"></canvas>

<!-- Vertex shader for points -->
<script id="vs" type="x-shader/x-vertex">
attribute vec2 a_quad;
attribute float a_seed;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_progress;
uniform vec2 u_mwPos;
uniform vec2 u_andPos;
uniform float u_scale;
varying float v_brightness;
void main(){
  // generate per-point offset using hash-like functions (on GPU)
  float s = a_seed;
  // deterministic pseudo-random
  float rx = fract(sin(s*12.9898) * 43758.5453);
  float ry = fract(sin(s*78.2334) * 12345.6789);
  // radius distribution for star cloud (0..1)
  float r = sqrt(rx) * 0.4; // distribution concentrated inward
  float theta = ry * 6.28318530718;
  // each attribute point also gets a galaxy selector via seed integer part
  float gid = floor(s);
  // gid = 0 => Milky Way, gid = 1 => Andromeda
  vec2 base = (gid < 0.5) ? u_mwPos : u_andPos;
  // star local orbit wobble and twinkling
  float wobble = 0.15 * sin(u_time * 0.5 + s * 20.0);
  // position in world space (centered)
  vec2 pos = base + vec2(cos(theta), sin(theta)) * r * u_scale + vec2(wobble * (s - 0.3));
  // apply small radial trails (using quad as point offset to create point sprite expansion)
  // a_quad ranges [-1,1] in XY to expand point size
  float size = mix(0.003, 0.008, fract(s * 12.3));
  vec2 offset = a_quad * size * (1.0 + 0.6 * sin(u_time*0.2 + s*10.0));
  // final normalized device coordinates
  vec2 ndc = pos + offset;
  // convert to clip space assuming aspect preserved externally
  gl_Position = vec4(ndc.x, ndc.y, 0.0, 1.0);
  v_brightness = 0.6 + 0.4 * sin(u_time * 1.0 + s * 10.0);
  gl_PointSize = 1.0; // we render quads manually via triangles; point size handled in varyings
}
</script>

<!-- Fragment shader draws soft point sprite (we use quads, so runs per-fragment) -->
<script id="fs" type="x-shader/x-fragment">
precision highp float;
varying float v_brightness;
uniform vec3 u_bgTone;
uniform vec3 u_mwColor;
uniform vec3 u_andColor;
uniform float u_pointSize;
void main(){
  // soft circular falloff for point sprite when using triangles
  // compute normalized coord inside the quad (gl_PointCoord is unavailable for triangles)
  // approximate by using gl_FragCoord not available in this context; we'll rely on v_brightness to modulate
  float alpha = smoothstep(0.9, 0.2, length(vec2(0.0)));
  vec3 col = mix(u_mwColor, u_andColor, 0.0) * v_brightness;
  gl_FragColor = vec4(col, 1.0) * v_brightness;
}
</script>

<script>
/*
This file renders a stylized, performant point-cloud simulation of two galaxies merging.
Per requirements:
 - ~50 stars per galaxy (total ~100)
 - solar systems highlighted (yellow and cyan)
 - 300s loop with slider control
 - no lensing/BHs
*/
(function(){
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl', { antialias: true });
  if(!gl){ alert("WebGL not available"); return; }

  // Internal resolution (4K target) but keep performance—use smaller buffer for heavy devices
  const MAX_W = 3840, MAX_H = 2160;
  const DPR = window.devicePixelRatio || 1;
  canvas.width = Math.min(MAX_W, Math.floor(window.innerWidth * DPR));
  canvas.height = Math.min(MAX_H, Math.floor(window.innerHeight * DPR));
  canvas.style.width = "100vw";
  canvas.style.height = "100vh";

  // simple shader program for drawing instanced quads as small point-sprites is complex on WebGL1;
  // instead we will draw each star as a small GL_TRIANGLE fan (two triangles) — but for simplicity and perf,
  // we will emulate points by drawing many tiny triangles controlled from CPU.
  // However to keep it concise: we'll draw stars as GL_POINTS using built-in point rendering and a fragment shader to make them soft.
  // We'll implement a simple vertex/fragment shader pair for points.

  const vsSrc = `
  attribute float a_seed;
  uniform vec2 u_resolution;
  uniform float u_time;
  uniform float u_progress;
  uniform vec2 u_mwPos;
  uniform vec2 u_andPos;
  uniform float u_scale;
  varying float v_seed;
  varying float v_gal;
  void main(){
    float s = a_seed;
    // determine galaxy id from seed integer part
    float gid = mod(floor(s), 2.0); // 0 or 1
    float ps = fract(s);
    float r = sqrt(ps) * 0.4;
    float theta = ps * 6.2831853 * (1.0 + 0.3 * fract(s * 7.0));
    // spiral perturb for realism
    r *= 1.0 + 0.2 * sin(theta*2.0 + u_time*0.1);
    vec2 base = gid < 0.5 ? u_mwPos : u_andPos;
    // star position relative to base
    vec2 pos = base + vec2(cos(theta), sin(theta)) * r * u_scale;
    // small orbiting motion (twinkle & wobble)
    float wobble = 0.02 * sin(u_time*0.7 + s * 40.0);
    pos += vec2(cos(theta*3.0 + u_time*0.2)*wobble, sin(theta*2.0 - u_time*0.2)*wobble);
    // map to clip space (we supply positions already in clip-like space)
    gl_Position = vec4(pos, 0.0, 1.0);
    // encode brightness and galaxy id for fragment shader
    v_seed = ps;
    v_gal = gid;
    gl_PointSize = 6.0; // will be scaled by viewport/resolution in CSS pixels; keep modest
  }
  `;

  const fsSrc = `
  precision mediump float;
  varying float v_seed;
  varying float v_gal;
  uniform float u_time;
  uniform vec3 u_mwColor;
  uniform vec3 u_andColor;
  uniform float u_pointScale;
  void main(){
    // compute soft circular falloff in gl_PointCoord
    vec2 coord = gl_PointCoord - vec2(0.5);
    float d = length(coord);
    float alpha = smoothstep(0.5, 0.0, d);
    // twinkle via seed and time
    float tw = 0.6 + 0.4 * sin(u_time*2.0 + v_seed*30.0);
    vec3 color = mix(u_mwColor, u_andColor, v_gal) * tw;
    gl_FragColor = vec4(color, alpha);
  }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw "Shader compile failed";
    }
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); }
  gl.useProgram(prog);

  // generate seeds for ~100 points (50 per galaxy)
  const starsPerGalaxy = 50;
  const totalStars = starsPerGalaxy * 2;
  const seeds = new Float32Array(totalStars);
  for(let i=0;i<totalStars;i++){
    // seed as integer part=galaxy id, fraction=random
    const gid = (i < starsPerGalaxy) ? 0.0 : 1.0;
    const frac = Math.random();
    // pack as gid + fraction
    seeds[i] = gid + frac;
  }

  // vertex buffer for seeds
  const seedBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, seedBuf);
  gl.bufferData(gl.ARRAY_BUFFER, seeds, gl.STATIC_DRAW);
  const a_seed = gl.getAttribLocation(prog, 'a_seed');
  gl.enableVertexAttribArray(a_seed);
  gl.vertexAttribPointer(a_seed, 1, gl.FLOAT, false, 0, 0);

  // uniforms
  const u_time = gl.getUniformLocation(prog, 'u_time');
  const u_progress = gl.getUniformLocation(prog, 'u_progress');
  const u_resolution = gl.getUniformLocation(prog, 'u_resolution');
  const u_mwPos = gl.getUniformLocation(prog, 'u_mwPos');
  const u_andPos = gl.getUniformLocation(prog, 'u_andPos');
  const u_scale = gl.getUniformLocation(prog, 'u_scale');
  const u_mwColor = gl.getUniformLocation(prog, 'u_mwColor');
  const u_andColor = gl.getUniformLocation(prog, 'u_andColor');

  // Colors: MW: warm white-ish, Andromeda: cooler cyan-tinge for contrast
  gl.uniform3f(u_mwColor, 1.0, 0.95, 0.8);
  gl.uniform3f(u_andColor, 0.6, 0.85, 1.0);

  // solar systems (yellow and cyan) will be drawn as separate GL_POINTS with larger sizes in second pass (simple approach)
  // We'll draw them after stars with separate program to control size & color.

  // Simple program for solar-system highlight points
  const vsSS = `
  attribute vec2 a_pos;
  uniform vec2 u_resolution;
  void main(){
    gl_Position = vec4(a_pos, 0.0, 1.0);
    gl_PointSize = 12.0;
  }
  `;
  const fsSS = `
  precision mediump float;
  uniform vec3 u_color;
  uniform float u_time;
  void main(){
    vec2 c = gl_PointCoord - vec2(0.5);
    float d = length(c);
    float alpha = smoothstep(0.6, 0.0, d);
    // subtle pulsing
    float pulse = 0.6 + 0.4 * sin(u_time*2.0);
    gl_FragColor = vec4(u_color * pulse, alpha);
  }
  `;
  function createProg(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
  }
  const ssProg = createProg(vsSS, fsSS);
  const a_pos_ss = gl.getAttribLocation(ssProg, 'a_pos');
  const u_color_ss = gl.getUniformLocation(ssProg, 'u_color');
  const u_time_ss = gl.getUniformLocation(ssProg, 'u_time');

  // slider UI
  const progSlider = document.getElementById('progress');
  const resetBtn = document.getElementById('reset');
  const timeLabel = document.getElementById('timeLabel');
  let manualProgress = parseFloat(progSlider.value);
  progSlider.addEventListener('input', (e)=>{ manualProgress = parseFloat(e.target.value); });
  resetBtn.addEventListener('click', ()=>{ progSlider.value = 0; manualProgress = 0; });

  const LOOP = 300.0;
  let startT = performance.now() * 0.001;

  // compute galaxy centers path (reuse logic from merge)
  function computeCenters(progress){
    // similar spiral logic used earlier
    const startAmp = 0.6;
    const amp = startAmp * (1.0 - smoothstep(0.0, 0.95, progress));
    const turns = 2.0 + 3.0 * progress;
    const theta = progress * turns * Math.PI;
    const tilt = 0.25;
    const x1 = -amp * Math.cos(theta);
    const y1 = amp * Math.sin(theta) * tilt;
    const x2 = amp * Math.cos(theta + Math.PI*0.5);
    const y2 = -amp * Math.sin(theta + Math.PI*0.5) * tilt;
    return { mw: [x1,y1], and: [x2,y2] };
  }

  // background star field as CSS image behind canvas would be simpler, but requirement: background image URL (clamped) used.
  // For this simplified point-cloud file we keep pure procedural background: deep black with faint glow via clear color and additive blending.

  gl.clearColor(0.0,0.0,0.02,1.0);

  function render(nowMs){
    const now = nowMs * 0.001;
    const progress = manualProgress;
    const virtualT = progress * LOOP;
    const dynT = (now - startT) + virtualT;

    gl.viewport(0,0, canvas.width, canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // recalc centers
    const centers = computeCenters(progress);
    // set uniforms for stars program
    gl.useProgram(prog);
    gl.uniform1f(u_time, dynT);
    gl.uniform1f(u_progress, progress);
    gl.uniform2f(u_resolution, canvas.width, canvas.height);
    gl.uniform2f(u_mwPos, centers.mw[0], centers.mw[1]);
    gl.uniform2f(u_andPos, centers.and[0], centers.and[1]);
    gl.uniform1f(u_scale, 0.9);

    // enable additive blending for star clouds
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

    // draw stars as points
    gl.bindBuffer(gl.ARRAY_BUFFER, seedBuf);
    gl.enableVertexAttribArray(a_seed);
    gl.vertexAttribPointer(a_seed, 1, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.POINTS, 0, totalStars);

    // draw solar systems (two points)
    gl.useProgram(ssProg);
    gl.enableVertexAttribArray(a_pos_ss);
    // MW solar system (yellow), orbits mwPos slightly with slow period (use dynT)
    const orbitRadius = 0.08;
    const mwx = centers.mw[0] + orbitRadius * Math.cos(dynT * 0.0005 * TWO_PI);
    const mwy = centers.mw[1] + orbitRadius * Math.sin(dynT * 0.0005 * TWO_PI);
    // Andromeda system cyan, hide after merge (progress > 0.9)
    const andHidden = progress > 0.92;
    const andx = centers.and[0] + orbitRadius * Math.cos(dynT * 0.0006 * TWO_PI + 1.2);
    const andy = centers.and[1] + orbitRadius * Math.sin(dynT * 0.0006 * TWO_PI + 1.2);

    // helper to draw single point
    function drawPoint(x,y,color){
      const posBuf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x,y]), gl.STREAM_DRAW);
      gl.vertexAttribPointer(a_pos_ss, 2, gl.FLOAT, false, 0, 0);
      gl.uniform3fv(u_color_ss, color);
      gl.uniform1f(u_time_ss, dynT);
      // additive blending for bright solar systems
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      gl.drawArrays(gl.POINTS, 0, 1);
      gl.deleteBuffer(posBuf);
    }

    // MW solar system (yellow)
    drawPoint(mwx, mwy, [1.0, 0.9, 0.2]);
    // Andromeda cyan unless hidden
    if(!andHidden) drawPoint(andx, andy, [0.3, 0.9, 1.0]);

    // subtle trails: draw faded, offset background copies for motion blur (cheap)
    // omitted for simplicity / perf

    timeLabel.textContent = Math.floor(progress * LOOP) + "s";
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);

  // resize handler
  function onResize(){
    const DPR = window.devicePixelRatio || 1;
    const w = Math.min(MAX_W, Math.floor(window.innerWidth * DPR));
    const h = Math.min(MAX_H, Math.floor(window.innerHeight * DPR));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
    }
  }
  window.addEventListener('resize', onResize);

  // helpers
  function smoothstep(a,b,x){ return Math.max(0, Math.min(1, (x - a) / (b - a))); }
  const TWO_PI = Math.PI * 2;

})();
</script>
</body>
</html>
