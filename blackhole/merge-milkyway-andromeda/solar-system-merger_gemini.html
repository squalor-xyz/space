<!DOCTYPE html>
<html>
<head>
    <title>Solar System Merger Visualization</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        .notice {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 3px;
            z-index: 10;
        }
        .notice a { color: rgba(255, 255, 255, 0.7); }
        .slider-container {
            position: absolute;
            bottom: 20px;
            left: 10%;
            width: 80%;
            z-index: 10;
        }
        .slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="notice">
        This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0).<br>
        Hosted at: <a href="https://jrobb.org/space/solar-system-merger.html" target="_blank">https://jrobb.org/space/solar-system-merger.html</a><br>
        Source: <a href="https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html" target="_blank">https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html</a>
    </div>

    <canvas id="glcanvas"></canvas>

    <div class="slider-container">
        <input type="range" id="progressSlider" min="0" max="300000" value="0" step="100">
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texcoord;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texcoord = a_position * 0.5 + 0.5;
        }
    </script>

    <script id="draw-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texcoord;
        uniform sampler2D u_fboTexture;

        void main() {
            gl_FragColor = texture2D(u_fboTexture, v_texcoord);
        }
    </script>

    <script id="sim-fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        varying vec2 v_texcoord;
        
        uniform vec2 u_resolution;
        uniform float u_aspect;
        uniform float u_time;
        uniform float u_progress;
        uniform sampler2D u_texture;

        // Galaxy centers
        uniform vec2 u_mw_pos;
        uniform vec2 u_and_pos;
        uniform float u_merge_factor; // 0 = separate, 1 = merged

        // --- Noise Functions ---
        float rand(vec2 n) { 
            return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        // --- Star Drawing Function ---
        float drawStars(vec2 p, vec2 center, float seed) {
            float stars = 0.0;
            const int NUM_STARS = 50;

            for (int i = 0; i < NUM_STARS; i++) {
                float i_f = float(i) + seed;
                float hash = rand(vec2(i_f, seed));
                
                // Hash-based offset (~0.2 radius from center)
                vec2 offset = vec2(rand(vec2(hash, 0.0)) - 0.5, rand(vec2(hash, 1.0)) - 0.5) * 0.4;
                
                // Wobble
                float wobble_t = u_time * (0.5 + hash * 0.5) + hash * 6.28;
                vec2 star_pos = center + offset + vec2(sin(wobble_t), cos(wobble_t)) * 0.01;
                
                float dist = length(p - star_pos);
                float star_size = 0.002 + hash * 0.001;
                
                // Twinkle
                float twinkle = 0.6 + 0.4 * sin(u_time * (2.0 + hash * 2.0));
                
                stars += smoothstep(star_size, star_size * 0.5, dist) * twinkle;
            }
            return stars;
        }

        // --- Solar System Highlight Function ---
        vec4 drawSolarSystems(vec2 p) {
            vec4 systems = vec4(0.0);
            float orbit_speed = u_time * 0.5; // Use u_time (seconds)
            float r = 0.1;

            // Our Solar System (Yellow)
            vec2 ss1_pos = u_mw_pos + vec2(r * cos(orbit_speed), r * sin(orbit_speed));
            float ss1_dist = length(p - ss1_pos);
            float ss1_size = 0.005;
            systems.rgb += vec3(1.0, 1.0, 0.0) * smoothstep(ss1_size, ss1_size * 0.5, ss1_dist);

            // Andromeda System (Cyan)
            vec2 ss2_pos = u_and_pos + vec2(r * cos(-orbit_speed * 0.8), r * sin(-orbit_speed * 0.8));
            float ss2_dist = length(p - ss2_pos);
            float ss2_size = 0.005;
            // Hide post-merge
            systems.rgb += vec3(0.0, 1.0, 1.0) * smoothstep(ss2_size, ss2_size * 0.5, ss2_dist) * (1.0 - u_merge_factor);
            
            systems.a = max(systems.r, max(systems.g, systems.b));
            return systems;
        }

        // --- Main Simulation ---
        void main() {
            // 1. Setup Coordinates
            vec2 pos = (v_texcoord - 0.5) * vec2(u_aspect, 1.0);
            
            // 2. Background (Clamped)
            vec4 color = texture2D(u_texture, v_texcoord);

            // 3. Draw Star Clouds
            // Draw MW stars
            float mw_stars = drawStars(pos, u_mw_pos, 1.0);
            // Draw Andromeda stars, fade out as they merge
            float and_stars = drawStars(pos, u_and_pos, 2.0) * (1.0 - u_merge_factor);
            // Draw Merged stars, fade in
            float merged_stars = drawStars(pos, u_mw_pos, 3.0) * u_merge_factor;
            
            vec3 star_color = vec3(1.0) * (mw_stars + and_stars + merged_stars);
            
            // 4. Draw Solar System Highlights
            vec4 ss = drawSolarSystems(pos);

            // 5. Composite
            // Additive blending for stars
            color.rgb += star_color;
            // Composite solar systems on top
            color.rgb = mix(color.rgb, ss.rgb, ss.a);
            
            gl_FragColor = vec4(color.rgb, 1.0);
        }
    </script>

    <script>
        window.onload = main;

        const FBO_WIDTH = 3840;
        const FBO_HEIGHT = 2160;
        const LOOP_DURATION = 300000.0; // 300s in ms

        let gl;
        let simProgramInfo;
        let drawProgramInfo;
        let quadBuffer;
        let fbo;
        let bgTexture;

        let manualControl = false;
        let progress = 0.0;
        let lastTime = 0.0;

        // --- Merger Parameters ---
        const MERGE_TIME = 0.8; // 80% through the loop

        function main() {
            const canvas = document.getElementById("glcanvas");
            gl = canvas.getContext("webgl");
            if (!gl) { alert("WebGL not supported!"); return; }

            // --- Shader Programs ---
            const vsSource = document.getElementById("vertex-shader").text;
            
            // 1. Simulation Program
            const simFsSource = document.getElementById("sim-fragment-shader").text;
            const simProgram = initShaderProgram(vsSource, simFsSource);
            simProgramInfo = {
                program: simProgram,
                attribLocations: {
                    a_position: gl.getAttribLocation(simProgram, "a_position"),
                },
                uniformLocations: {
                    u_resolution: gl.getUniformLocation(simProgram, "u_resolution"),
                    u_aspect: gl.getUniformLocation(simProgram, "u_aspect"),
                    u_time: gl.getUniformLocation(simProgram, "u_time"),
                    u_progress: gl.getUniformLocation(simProgram, "u_progress"),
                    u_texture: gl.getUniformLocation(simProgram, "u_texture"),
                    u_mw_pos: gl.getUniformLocation(simProgram, "u_mw_pos"),
                    u_and_pos: gl.getUniformLocation(simProgram, "u_and_pos"),
                    u_merge_factor: gl.getUniformLocation(simProgram, "u_merge_factor"),
                },
            };

            // 2. Screen Draw Program
            const drawFsSource = document.getElementById("draw-fragment-shader").text;
            const drawProgram = initShaderProgram(vsSource, drawFsSource);
            drawProgramInfo = {
                program: drawProgram,
                attribLocations: {
                    a_position: gl.getAttribLocation(drawProgram, "a_position"),
                },
                uniformLocations: {
                    u_fboTexture: gl.getUniformLocation(drawProgram, "u_fboTexture"),
                },
            };

            quadBuffer = initQuadBuffer();
            fbo = createFramebuffer(FBO_WIDTH, FBO_HEIGHT);
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // --- Load Texture ---
            const bgUrl = "https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg";
            // Use CLAMP_TO_EDGE for this one
            bgTexture = initTexture(bgUrl, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, () => {
                requestAnimationFrame(render);
            });

            // --- Slider Control ---
            const slider = document.getElementById("progressSlider");
            slider.addEventListener('mousedown', () => { manualControl = true; });
            slider.addEventListener('input', () => {
                progress = parseFloat(slider.value) / LOOP_DURATION;
            });
            slider.addEventListener('mouseup', () => { manualControl = false; });
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function smoothstep(edge0, edge1, x) {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
        }

        function render(now) {
            // --- Time and Progress Update ---
            if (lastTime === 0.0) lastTime = now;
            const deltaTime = now - lastTime;
            lastTime = now;

            if (!manualControl) {
                progress = (progress + (deltaTime / LOOP_DURATION)) % 1.0;
                document.getElementById("progressSlider").value = progress * LOOP_DURATION;
            }
            const timeInSeconds = now * 0.001;

            resizeCanvasToDisplaySize(gl.canvas);

            // --- Calculate Uniforms (Same path as File 2) ---
            const mergeFactor = smoothstep(MERGE_TIME - 0.05, MERGE_TIME, progress);
            
            const turns = 4.0;
            const theta = progress * turns * 2.0 * Math.PI;
            const ampStart = 0.4;
            const amp = ampStart * (1.0 - progress / MERGE_TIME);
            
            let pos1_base = [amp * Math.cos(theta), amp * Math.sin(theta)];
            let pos2_base = [-amp * Math.cos(theta), -amp * Math.sin(theta)];
            
            const mergedPos = [0.0, 0.0];

            const mw_pos = [
                lerp(pos1_base[0], mergedPos[0], mergeFactor),
                lerp(pos1_base[1], mergedPos[1], mergeFactor)
            ];
            const and_pos = [
                lerp(pos2_base[0], mergedPos[0], mergeFactor),
                lerp(pos2_base[1], mergedPos[1], mergeFactor)
            ];

            // --- Pass 1: Render Simulation to FBO ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            gl.viewport(0, 0, FBO_WIDTH, FBO_HEIGHT);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(simProgramInfo.program);
            
            // Set uniforms
            gl.uniform2f(simProgramInfo.uniformLocations.u_resolution, FBO_WIDTH, FBO_HEIGHT);
            gl.uniform1f(simProgramInfo.uniformLocations.u_aspect, FBO_WIDTH / FBO_HEIGHT);
            gl.uniform1f(simProgramInfo.uniformLocations.u_time, timeInSeconds);
            gl.uniform1f(simProgramInfo.uniformLocations.u_progress, progress);
            gl.uniform1f(simProgramInfo.uniformLocations.u_merge_factor, mergeFactor);
            gl.uniform2fv(simProgramInfo.uniformLocations.u_mw_pos, mw_pos);
            gl.uniform2fv(simProgramInfo.uniformLocations.u_and_pos, and_pos);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(simProgramInfo.uniformLocations.u_texture, 0);

            // Draw quad
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(simProgramInfo.attribLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(simProgramInfo.attribLocations.a_position);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            // --- Pass 2: Render FBO to Screen ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(drawProgramInfo.program);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.uniform1i(drawProgramInfo.uniformLocations.u_fboTexture, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(drawProgramInfo.attribLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(drawProgramInfo.attribLocations.a_position);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions (Identical to File 1) ---

        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initQuadBuffer() {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const positions = [-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return buffer;
        }

        function initTexture(url, wrapS, wrapT, onloadCallback) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Placeholder pixel
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

            const image = new Image();
            image.crossOrigin = "anonymous";
            
            let callback = onloadCallback;

            const startLoop = () => {
                if (callback) {
                    callback();
                    callback = null; // Prevent double-call
                }
            };

            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                startLoop();
            };
            
            image.onerror = () => {
                console.error("Failed to load texture:", url);
                startLoop(); // Start render loop anyway, will use placeholder
            };
            
            image.src = url;
            return texture;
        }

        function createFramebuffer(width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            const renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            return { framebuffer: framebuffer, texture: texture, renderbuffer: renderbuffer };
        }
        
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
    </script>
</body>
</html>
