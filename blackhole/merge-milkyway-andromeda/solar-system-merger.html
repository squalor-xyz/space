<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar System in Galaxy Merger Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #notice { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; font-size: 12px; z-index: 10; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; }
        #slider { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80%; z-index: 10; }
    </style>
</head>
<body>
    <div id="notice">This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0). Hosted at https://jrobb.org/space/solar-system-merger.html. Source: https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html.</div>
    <canvas id="canvas"></canvas>
    <input type="range" id="slider" min="0" max="1" step="0.001" value="0">
    <script>
        const canvas = document.getElementById('canvas');
        const slider = document.getElementById('slider');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        const WIDTH = 4096;
        const HEIGHT = 2160;
        const LOOP_DURATION = 300;

        const vsQuadSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fsGalaxiesSource = `
            precision highp float;
            uniform float time;
            uniform vec2 resolution;
            uniform vec2 mwPos;
            uniform vec2 andPos;
            uniform bool merged;
            uniform sampler2D background;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float star(vec2 uv, vec2 pos, float size) {
                vec2 d = uv - pos;
                float r = length(d);
                return smoothstep(size, 0.0, r) * (0.5 + 0.5 * hash(pos));
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 color = texture2D(background, uv);

                for (int i = 0; i < 25; i++) {
                    float fi = float(i);
                    vec2 offset = vec2(hash(vec2(fi, 0.0)) - 0.5, hash(vec2(fi, 1.0)) - 0.5) * 0.2;
                    vec2 pos = mwPos + offset * (1.0 + sin(time * 0.001 + fi) * 0.05);
                    color.rgb += vec3(star(uv, pos, 0.001));
                }

                if (!merged) {
                    for (int i = 0; i < 25; i++) {
                        float fi = float(i) + 25.0;
                        vec2 offset = vec2(hash(vec2(fi, 0.0)) - 0.5, hash(vec2(fi, 1.0)) - 0.5) * 0.2;
                        vec2 pos = andPos + offset * (1.0 + sin(time * 0.001 + fi) * 0.05);
                        color.rgb += vec3(star(uv, pos, 0.001));
                    }
                }

                vec2 ourPos = mwPos + vec2(0.1 * sin(time * 0.0005), 0.1 * cos(time * 0.0005));
                color.rgb += vec3(1.0, 1.0, 0.0) * star(uv, ourPos, 0.005);

                vec2 andSolarPos = andPos + vec2(0.1 * cos(time * 0.0005), 0.1 * sin(time * 0.0005));
                color.rgb += vec3(0.0, 1.0, 1.0) * star(uv, andSolarPos, 0.005) * float(!merged);

                gl_FragColor = color;
            }
        `;

        const fsBlitSource = `
            precision highp float;
            uniform sampler2D highres;
            uniform vec2 resolution;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                gl_FragColor = texture2D(highres, uv);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const galaxiesProgram = createProgram(gl, vsQuadSource, fsGalaxiesSource);
        const blitProgram = createProgram(gl, vsQuadSource, fsBlitSource);

        const positionLocation = gl.getAttribLocation(galaxiesProgram, 'position');
        const timeLocation = gl.getUniformLocation(galaxiesProgram, 'time');
        const resLocation = gl.getUniformLocation(galaxiesProgram, 'resolution');
        const mwPosLocation = gl.getUniformLocation(galaxiesProgram, 'mwPos');
        const andPosLocation = gl.getUniformLocation(galaxiesProgram, 'andPos');
        const mergedLocation = gl.getUniformLocation(galaxiesProgram, 'merged');
        const bgLocation = gl.getUniformLocation(galaxiesProgram, 'background');

        const highresLocation = gl.getUniformLocation(blitProgram, 'highres');
        const blitResLocation = gl.getUniformLocation(blitProgram, 'resolution');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            1, -1, 1, 1, -1, 1
        ]), gl.STATIC_DRAW);

        const bgTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, bgTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        };
        img.onerror = () => console.error('Failed to load background');
        img.src = 'https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg';

        const rtTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, rtTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, WIDTH, HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
        window.addEventListener('resize', resize);

        let startTime = performance.now();
        let useSlider = false;
        let progress = 0.0;

        slider.oninput = (e) => {
            progress = parseFloat(e.target.value);
            useSlider = true;
        };

        slider.onmouseup = slider.ontouchend = () => {
            useSlider = false;
            startTime = performance.now() - (progress * LOOP_DURATION * 1000);
        };

        function updatePositions(t) {
            let prog = useSlider ? progress : ((t * 1000) % (LOOP_DURATION * 1000)) / (LOOP_DURATION * 1000);
            slider.value = prog;
            let mwX, mwY, andX, andY, isMerged;

            if (prog > 0.8) {
                isMerged = true;
                mwX = 0.5;
                mwY = 0.5;
                andX = 0.5;
                andY = 0.5;
            } else {
                isMerged = false;
                let theta = prog * 10.0 * 3.14159;
                let amp = 0.4 * (1.0 - prog);
                mwX = 0.5 + amp * Math.cos(theta);
                mwY = 0.5 + amp * Math.sin(theta);
                andX = 0.5 - amp * Math.cos(theta);
                andY = 0.5 - amp * Math.sin(theta);
            }

            return { mwPos: [mwX, mwY], andPos: [andX, andY], merged: isMerged };
        }

        function render(now) {
            const t = useSlider ? progress * LOOP_DURATION : (now - startTime) / 1000.0;
            const posState = updatePositions(t);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.viewport(0, 0, WIDTH, HEIGHT);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(galaxiesProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(bgLocation, 0);

            gl.uniform1f(timeLocation, t);
            gl.uniform2f(resLocation, WIDTH, HEIGHT);
            gl.uniform2fv(mwPosLocation, posState.mwPos);
            gl.uniform2fv(andPosLocation, posState.andPos);
            gl.uniform1i(mergedLocation, posState.merged ? 1 : 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(blitProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, rtTexture);
            gl.uniform1i(highresLocation, 0);
            gl.uniform2f(blitResLocation, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
