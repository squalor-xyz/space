<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sagittarius A* Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #notice { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; font-size: 12px; z-index: 10; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; }
        #slider { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80%; z-index: 10; }
    </style>
</head>
<body>
    <div id="notice">This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0). Hosted at https://jrobb.org/space/sagittarius-a.html. Source: https://github.com/squalor-xyz/space/blob/main/sagittarius-a.html.</div>
    <canvas id="canvas"></canvas>
    <input type="range" id="slider" min="0" max="1" step="0.001" value="0">
    <script>
        const canvas = document.getElementById('canvas');
        const slider = document.getElementById('slider');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        const WIDTH = 4096;
        const HEIGHT = 2160;
        const LOOP_DURATION = 300;

        const vsSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fsSimSource = `
            precision highp float;
            uniform sampler2D background;
            uniform float time;
            uniform vec2 resolution;
            uniform vec2 bhPos;
            uniform float rs;
            uniform float spin;
            uniform float strength;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            float fbm(vec2 p) {
                float f = 0.0;
                f += 0.5000 * noise(p); p *= 2.02;
                f += 0.2500 * noise(p); p *= 2.03;
                f += 0.1250 * noise(p);
                return f / 0.875;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec2 d = uv - bhPos;
                float r = length(d);
                vec2 hat = r > 0.0 ? d / r : vec2(0.0);

                vec4 color = vec4(0.0);

                if (r > rs) {
                    float deflectionMag = strength * rs * rs / (r * r);
                    float frameDrag = spin * 0.15 * rs / (r * r * r);
                    vec2 deflection = deflectionMag * hat + frameDrag * vec2(-d.y, d.x);
                    vec2 trueUv = fract(uv + deflection);
                    color = texture2D(background, trueUv);
                    trueUv = fract(uv + deflection * 1.15);
                    color += 0.3 * texture2D(background, trueUv);
                    trueUv = fract(uv + deflection * 0.85);
                    color += 0.2 * texture2D(background, trueUv);
                    color /= 1.5;
                }

                // Photon sphere
                float photonSphere = smoothstep(0.01, 0.0, abs(r - 1.5 * rs)) * (1.0 - smoothstep(0.0, 0.02, abs(r - 1.5 * rs)));
                float irreg = fbm(d * 10.0 + time * 0.03) * 0.5 + 0.5;
                photonSphere *= irreg;
                float asym = 1.0 + 0.6 * spin * sin(atan(d.y, d.x) + 1.57);
                photonSphere *= asym;
                vec3 sphereColor = vec3(1.0, 0.65, 0.25) * (0.7 + 0.3 * sin(time * 0.3));
                color = mix(color, vec4(sphereColor, 1.0), 0.4 * photonSphere);

                // Secondary ring for realism
                float secondaryRingDist = abs(r - 2.6 * rs);
                float secondaryRing = smoothstep(0.015, 0.0, secondaryRingDist) * (1.0 - smoothstep(0.0, 0.03, secondaryRingDist)) * 0.4;
                secondaryRing *= irreg * 0.8;
                secondaryRing *= asym * 0.8;
                color = mix(color, vec4(sphereColor * 0.6, 1.0), 0.3 * secondaryRing);

                float inner = 3.0 * rs;
                float outer = 15.0 * rs;
                if (r > inner && r < outer) {
                    float phi = atan(d.y, d.x);
                    float density = 1.0 - (r - inner) / (outer - inner);
                    density *= exp(-abs(phi) / 0.8);
                    float swirl = phi - time * 0.1 / sqrt(r) + spin * time * 0.25;
                    float turb = fbm(vec2(r * 5.0, swirl * 2.5)) * 0.6;
                    density += turb;
                    density *= 0.5 + 0.5 * sin(time * 1.0);
                    float doppler = 1.0 + 0.8 * spin * sin(phi + 1.57);
                    density *= doppler;
                    vec3 baseCol = mix(vec3(1.0, 0.4, 0.1), vec3(1.0, 0.8, 0.3), (r - inner) / (outer - inner));
                    float doppSign = sin(phi + 1.57);
                    if (doppSign > 0.0) {
                        baseCol = mix(baseCol, vec3(1.0, 0.9, 0.5), doppSign * spin * 0.6);
                    } else {
                        baseCol = mix(baseCol, vec3(1.0, 0.3, 0.05), -doppSign * spin * 0.6);
                    }
                    vec3 diskCol = baseCol * density * 0.7;
                    diskCol += 0.3 * fbm(d * 8.0) * diskCol;
                    color.rgb = mix(color.rgb, diskCol, 0.6 * density);
                }

                if (r < rs) {
                    color = vec4(0.0);
                } else if (r < 2.0 * rs) {
                    float shadow = 1.0 - smoothstep(rs, 2.0 * rs, r);
                    color.rgb *= (1.0 - 0.7 * shadow);
                }

                gl_FragColor = color;
            }
        `;

        const fsBlitSource = `
            precision highp float;
            uniform sampler2D highres;
            uniform vec2 resolution;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                gl_FragColor = texture2D(highres, uv);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const simProgram = createProgram(gl, vsSource, fsSimSource);
        const blitProgram = createProgram(gl, vsSource, fsBlitSource);

        const positionLocation = gl.getAttribLocation(simProgram, 'position');
        const bgLocation = gl.getUniformLocation(simProgram, 'background');
        const timeLocation = gl.getUniformLocation(simProgram, 'time');
        const resLocation = gl.getUniformLocation(simProgram, 'resolution');
        const bhPosLocation = gl.getUniformLocation(simProgram, 'bhPos');
        const rsLocation = gl.getUniformLocation(simProgram, 'rs');
        const spinLocation = gl.getUniformLocation(simProgram, 'spin');
        const strengthLocation = gl.getUniformLocation(simProgram, 'strength');

        const highresLocation = gl.getUniformLocation(blitProgram, 'highres');
        const blitResLocation = gl.getUniformLocation(blitProgram, 'resolution');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            1, -1, 1, 1, -1, 1
        ]), gl.STATIC_DRAW);

        const bgTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, bgTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        };
        img.onerror = () => console.error('Failed to load background');
        img.src = 'https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg';

        const rtTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, rtTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 4096, 2160, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
        window.addEventListener('resize', resize);

        let startTime = performance.now();
        let useSlider = false;
        let progress = 0.0;

        slider.oninput = (e) => {
            progress = parseFloat(e.target.value);
            useSlider = true;
        };

        slider.onmouseup = slider.ontouchend = () => {
            useSlider = false;
            startTime = performance.now() - (progress * LOOP_DURATION * 1000);
        };

        function render(now) {
            const t = useSlider ? progress * LOOP_DURATION : (now - startTime) / 1000.0;
            slider.value = useSlider ? progress : ((t % LOOP_DURATION) / LOOP_DURATION);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.viewport(0, 0, 4096, 2160);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(simProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(bgLocation, 0);

            gl.uniform1f(timeLocation, t);
            gl.uniform2f(resLocation, 4096, 2160);
            gl.uniform2f(bhPosLocation, 0.5, 0.5);
            gl.uniform1f(rsLocation, 0.1);
            gl.uniform1f(spinLocation, 0.7);
            gl.uniform1f(strengthLocation, 0.5);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(blitProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, rtTexture);
            gl.uniform1i(highresLocation, 0);
            gl.uniform2f(blitResLocation, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
