<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sagittarius A* Simulation - Improved</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }
        canvas {
            display: block;
        }
        #license {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="license">This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0). Hosted at https://jrobb.org/space/sagittarius-a.html. Source: https://github.com/squalor-xyz/space/blob/main/sagittarius-a.html.</div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            alert('WebGL 2.0 not supported');
            throw new Error('WebGL 2.0 not supported');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const vsSource = `#version 300 es
            in vec2 a_position;
            out vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texcoord = a_position * 0.5 + 0.5;
            }
        `;

        const fsSource = `#version 300 es
            precision highp float;
            out vec4 fragColor;
            in vec2 v_texcoord;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_accDisk;

            #define SPEED_OF_LIGHT 1.0
            #define EVENT_HORIZON_RADIUS 1.0
            #define BACKGROUND_DISTANCE 10000.0
            #define PI 3.14159265359
            #define INNER_DISK_RADIUS 3.0
            #define OUTER_DISK_RADIUS 25.0
            #define DISK_THICKNESS 1.0
            #define M (EVENT_HORIZON_RADIUS / 2.0)

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            float fbm(vec3 pos) {
                float value = 0.0;
                float amp = 0.5;
                float freq = 1.0;
                for (int i = 0; i < 6; i++) {
                    value += amp * noise(pos.xz * freq);
                    amp *= 0.5;
                    freq *= 2.0;
                }
                return value;
            }

            vec3 geodesic_equation(vec3 position, float h2) {
                return -1.5 * h2 * position / pow(length(position), 5.0);
            }

            vec4 trace_ray(vec3 ray_pos, vec3 ray_dir) {
                vec3 pos = ray_pos;
                vec3 dir = normalize(ray_dir); // Ensure normalized
                float h2 = pow(length(cross(pos, dir)), 2.0);
                const int max_steps = 512;
                const float step_scale = 0.002;
                for (int i = 0; i < max_steps; i++) {
                    float dist = length(pos);
                    if (dist <= EVENT_HORIZON_RADIUS) {
                        return vec4(0.0, 0.0, 0.0, 1.0);
                    }
                    float r = length(pos.xz);
                    if (u_accDisk > 0.5 && r > INNER_DISK_RADIUS && r < OUTER_DISK_RADIUS && abs(pos.y) < DISK_THICKNESS) {
                        float omega = sqrt(M / pow(r, 3.0));
                        float phi = atan(pos.z, pos.x) + u_time * omega * 5.0; // Scaled for visible swirling
                        vec3 disk_pos = vec3(pos.x, pos.y, pos.z) + vec3(phi * 5.0, 0.0, 0.0);
                        float density = fbm(disk_pos) * smoothstep(OUTER_DISK_RADIUS, INNER_DISK_RADIUS, r);
                        vec3 disk_base = vec3(1.0, 0.5, 0.1) * (1.0 - (r - INNER_DISK_RADIUS) / (OUTER_DISK_RADIUS - INNER_DISK_RADIUS));
                        vec3 shift_dir = normalize(cross(vec3(pos.x, 0.0, pos.z), vec3(0.0, 1.0, 0.0)));
                        float vel_dot = dot(dir, shift_dir);
                        float beta = omega * r; // Approximate velocity
                        float doppler = sqrt((1.0 - beta) / (1.0 + beta)) / (1.0 + vel_dot * beta); // Simplified
                        float g_redshift = sqrt(1.0 - EVENT_HORIZON_RADIUS / r);
                        vec3 disk_color = disk_base * density * doppler * g_redshift * 2.0;
                        return vec4(disk_color, 1.0);
                    }
                    if (dist > BACKGROUND_DISTANCE) {
                        break;
                    }
                    float step_size = dist * dist * step_scale;
                    vec3 k1 = geodesic_equation(pos, h2) * step_size;
                    vec3 k2 = geodesic_equation(pos + 0.5 * step_size * dir + 0.5 * k1, h2) * step_size;
                    vec3 k3 = geodesic_equation(pos + 0.5 * step_size * dir + 0.5 * k2, h2) * step_size;
                    vec3 k4 = geodesic_equation(pos + step_size * dir + k3, h2) * step_size;
                    vec3 accel = (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;
                    pos += step_size * dir;
                    dir += accel;
                    dir = normalize(dir);
                }
                // Background
                vec3 final_dir = normalize(pos);
                float star_density = 0.0;
                for (int j = 0; j < 100; j++) {
                    float fj = float(j);
                    vec3 star_pos = normalize(vec3(sin(fj * 0.1), cos(fj * 0.13), sin(fj * 0.17))) * 1000.0;
                    if (dot(final_dir, normalize(star_pos)) > 0.9999) {
                        star_density += 0.01;
                    }
                }
                vec3 bg = vec3(0.01, 0.01, 0.03) + vec3(1.0) * star_density * 5.0;
                // Photon ring enhancement
                float impact_param = length(cross(ray_pos, ray_dir));
                if (abs(impact_param - 2.598 * EVENT_HORIZON_RADIUS) < 0.05) {
                    bg += vec3(1.0, 0.8, 0.5) * 0.8;
                }
                return vec4(bg, 1.0);
            }

            void main() {
                vec2 uv = (v_texcoord * 2.0 - 1.0) * vec2(u_resolution.x / u_resolution.y, 1.0);
                vec3 cam_pos = vec3(0.0, 20.0 * EVENT_HORIZON_RADIUS, 10.0 * EVENT_HORIZON_RADIUS);
                vec3 cam_target = vec3(0.0, 0.0, 0.0);
                vec3 cam_forward = normalize(cam_target - cam_pos);
                vec3 cam_right = normalize(cross(vec3(0.0, 1.0, 0.0), cam_forward));
                vec3 cam_up = cross(cam_forward, cam_right);
                vec3 ray_dir = normalize(cam_forward + uv.x * cam_right + uv.y * cam_up);
                fragColor = trace_ray(cam_pos, ray_dir);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const program = createProgram(gl, vsSource, fsSource);
        gl.useProgram(program);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const accDiskLocation = gl.getUniformLocation(program, 'u_accDisk');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1,  -1, 1,
            -1, 1,   1, -1,   1, 1
        ]), gl.STATIC_DRAW);

        let startTime = Date.now();

        function render() {
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, (Date.now() - startTime) / 1000.0);
            gl.uniform1f(accDiskLocation, 1.0);

            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
