<!DOCTYPE html>
<html>
<head>
    <title>Sagittarius A* Simulation</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        .notice {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 3px;
            z-index: 10;
        }
        .notice a { color: rgba(255, 255, 255, 0.7); }
        .slider-container {
            position: absolute;
            bottom: 20px;
            left: 10%;
            width: 80%;
            z-index: 10;
        }
        .slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="notice">
        This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0).<br>
        Hosted at: <a href="https://squalor.xyz/space/bh/" target="_blank">https://squalor.xyz/space/bh/</a><br>
        Source: <a href="https://github.com/squalor-xyz/space/" target="_blank">https://github.com/squalor-xyz/space/</a>
    </div>

    <canvas id="glcanvas"></canvas>

    <div class="slider-container">
        <input type="range" id="progressSlider" min="0" max="300000" value="0" step="100">
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texcoord;

        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texcoord = a_position * 0.5 + 0.5;
        }
    </script>

    <script id="draw-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texcoord;
        uniform sampler2D u_fboTexture;

        void main() {
            gl_FragColor = texture2D(u_fboTexture, v_texcoord);
        }
    </script>

    <script id="sim-fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        varying vec2 v_texcoord;
        
        uniform vec2 u_resolution;
        uniform float u_aspect;
        uniform float u_time;
        uniform float u_progress;
        uniform sampler2D u_texture;

        // --- Black Hole Parameters ---
        const vec2  BH_POS      = vec2(0.0);
        const float BH_RS       = 0.015; // Schwarzschild Radius
        const float BH_SPIN     = 0.7;
        const float BH_STRENGTH = 0.3;   // Lensing strength

        // --- Noise Functions ---
        float rand(vec2 n) { 
            return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(vec2 p) {
            vec2 ip = floor(p);
            vec2 u = fract(p);
            u = u*u*(3.0-2.0*u);
            
            float res = mix(
                mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
                mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
            return res*res;
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            vec2 shift = vec2(100.0);
            // 3 Octaves
            v += noise(p) * a; p = p * 2.0 + shift; a *= 0.5;
            v += noise(p) * a; p = p * 2.0 + shift; a *= 0.5;
            v += noise(p) * a;
            return v;
        }

        // --- Main Simulation ---
        void main() {
            // 1. Setup Coordinates
            // Centered, aspect-corrected coordinates
            vec2 pos = (v_texcoord - 0.5) * vec2(u_aspect, 1.0);
            
            vec2 D = pos - BH_POS;
            float r = length(D);
            float r2 = r * r;
            float angle = atan(D.y, D.x);

            // 2. Black Hole Shadow
            // Inside the radius, it's just black
            if (r < BH_RS) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                return;
            }

            // 3. Gravitational Lensing
            // Calculate deflection for background stars
            vec2 deflection = normalize(D) * BH_STRENGTH * (BH_RS / r);
            vec2 lensed_pos = pos + deflection;
            // Convert back to 0-1 texture coordinates
            vec2 lensed_uv = lensed_pos / vec2(u_aspect, 1.0) + 0.5;
            vec4 background = texture2D(u_texture, lensed_uv);

            // 4. Accretion Disk (Procedural)
            float disk_radius_inner = BH_RS * 1.5;
            float disk_radius_outer = BH_RS * 12.0;
            
            // Mask for the disk area
            float disk_mask = smoothstep(disk_radius_inner, disk_radius_inner + 0.01, r) * (1.0 - smoothstep(disk_radius_outer, disk_radius_outer + 0.01, r));

            vec4 disk_color = vec4(0.0);
            if (disk_mask > 0.0) {
                // Swirl effect based on spin and radius
                // Use u_progress for continuous loop-based rotation, u_time for fine shimmer
                float swirl = (BH_SPIN / (r2 + 0.1)) * 0.5 + u_progress * -20.0;
                
                // Noise coordinates
                vec2 noise_uv = vec2(angle * 3.0 + swirl, r * 10.0);
                float noise_val = fbm(noise_uv + u_time * 0.1);
                
                // Base disk color (hot orange/yellow)
                vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.9, 0.5), smoothstep(disk_radius_outer, disk_radius_inner, r));
                
                // Brightness profile
                float brightness = pow(noise_val, 2.5);
                brightness *= smoothstep(disk_radius_outer, disk_radius_inner, r); // Brighter inside
                brightness *= (1.0 + pow(r, -1.5) * 0.05); // Inner rim glow
                brightness *= disk_mask;

                disk_color = vec4(color * brightness, brightness * 0.8);
            }

            // 5. Photon Ring (Einstein Ring)
            float ring_radius = BH_RS * 1.2;
            float ring_width = 0.003;
            float ring = smoothstep(ring_radius - ring_width, ring_radius, r) * (1.0 - smoothstep(ring_radius, ring_radius + ring_width, r));
            
            vec4 ring_color = vec4(0.0);
            if (ring > 0.0) {
                // Modulate brightness based on angle (Doppler beaming) and time
                float ring_noise = fbm(vec2(angle * 10.0, u_time * 0.2));
                float doppler = 0.7 + 0.3 * sin(angle * 3.0 + u_time * 0.5);
                float ring_brightness = ring * (1.0 + ring_noise * 0.5) * doppler * 2.5;
                
                ring_color = vec4(vec3(1.0, 0.8, 0.6) * ring_brightness, ring_brightness);
            }

            // 6. Composite
            // Start with lensed background
            vec4 final_color = background;
            // Alpha-blend the disk on top
            final_color.rgb = mix(final_color.rgb, disk_color.rgb, disk_color.a);
            // Additively blend the bright photon ring
            final_color.rgb += ring_color.rgb;

            gl_FragColor = vec4(final_color.rgb, 1.0);
        }
    </script>

    <script>
        window.onload = main;

        const FBO_WIDTH = 3840;
        const FBO_HEIGHT = 2160;
        const LOOP_DURATION = 300000.0; // 300s in ms

        let gl;
        let simProgramInfo;
        let drawProgramInfo;
        let quadBuffer;
        let fbo;
        let bgTexture;

        let manualControl = false;
        let progress = 0.0;
        let lastTime = 0.0;

        function main() {
            const canvas = document.getElementById("glcanvas");
            gl = canvas.getContext("webgl");
            if (!gl) {
                alert("WebGL not supported!");
                return;
            }

            // --- Shader Programs ---
            const vsSource = document.getElementById("vertex-shader").text;
            
            // 1. Simulation Program
            const simFsSource = document.getElementById("sim-fragment-shader").text;
            const simProgram = initShaderProgram(vsSource, simFsSource);
            simProgramInfo = {
                program: simProgram,
                attribLocations: {
                    a_position: gl.getAttribLocation(simProgram, "a_position"),
                },
                uniformLocations: {
                    u_resolution: gl.getUniformLocation(simProgram, "u_resolution"),
                    u_aspect: gl.getUniformLocation(simProgram, "u_aspect"),
                    u_time: gl.getUniformLocation(simProgram, "u_time"),
                    u_progress: gl.getUniformLocation(simProgram, "u_progress"),
                    u_texture: gl.getUniformLocation(simProgram, "u_texture"),
                },
            };

            // 2. Screen Draw Program
            const drawFsSource = document.getElementById("draw-fragment-shader").text;
            const drawProgram = initShaderProgram(vsSource, drawFsSource);
            drawProgramInfo = {
                program: drawProgram,
                attribLocations: {
                    a_position: gl.getAttribLocation(drawProgram, "a_position"),
                },
                uniformLocations: {
                    u_fboTexture: gl.getUniformLocation(drawProgram, "u_fboTexture"),
                },
            };

            quadBuffer = initQuadBuffer();
            fbo = createFramebuffer(FBO_WIDTH, FBO_HEIGHT);
            
            // --- GL Settings ---
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // --- Load Texture ---
            const bgUrl = "https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg";
            bgTexture = initTexture(bgUrl, gl.REPEAT, gl.REPEAT, () => {
                // Start render loop only after texture is loaded or fails
                requestAnimationFrame(render);
            });

            // --- Slider Control ---
            const slider = document.getElementById("progressSlider");
            slider.addEventListener('mousedown', () => { manualControl = true; });
            slider.addEventListener('input', () => {
                progress = parseFloat(slider.value) / LOOP_DURATION;
            });
            slider.addEventListener('mouseup', () => { manualControl = false; });
        }

        function render(now) {
            // --- Time and Progress Update ---
            if (lastTime === 0.0) lastTime = now;
            const deltaTime = now - lastTime;
            lastTime = now;

            if (!manualControl) {
                progress = (progress + (deltaTime / LOOP_DURATION)) % 1.0;
                document.getElementById("progressSlider").value = progress * LOOP_DURATION;
            }
            const timeInSeconds = now * 0.001;

            // --- Resize Canvas to Match Display ---
            resizeCanvasToDisplaySize(gl.canvas);

            // --- Pass 1: Render Simulation to FBO ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            gl.viewport(0, 0, FBO_WIDTH, FBO_HEIGHT);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(simProgramInfo.program);
            
            // Set uniforms
            gl.uniform2f(simProgramInfo.uniformLocations.u_resolution, FBO_WIDTH, FBO_HEIGHT);
            gl.uniform1f(simProgramInfo.uniformLocations.u_aspect, FBO_WIDTH / FBO_HEIGHT);
            gl.uniform1f(simProgramInfo.uniformLocations.u_time, timeInSeconds);
            gl.uniform1f(simProgramInfo.uniformLocations.u_progress, progress);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(simProgramInfo.uniformLocations.u_texture, 0);

            // Draw quad
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(simProgramInfo.attribLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(simProgramInfo.attribLocations.a_position);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            // --- Pass 2: Render FBO to Screen ---
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(drawProgramInfo.program);

            // Bind FBO texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.uniform1i(drawProgramInfo.uniformLocations.u_fboTexture, 0);

            // Draw quad
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.vertexAttribPointer(drawProgramInfo.attribLocations.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(drawProgramInfo.attribLocations.a_position);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            // Loop
            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---

        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initQuadBuffer() {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const positions = [-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return buffer;
        }

        function initTexture(url, wrapS, wrapT, onloadCallback) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Placeholder pixel
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

            const image = new Image();
            image.crossOrigin = "anonymous";
            
            let callback = onloadCallback;

            const startLoop = () => {
                if (callback) {
                    callback();
                    callback = null; // Prevent double-call
                }
            };

            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                startLoop();
            };
            
            image.onerror = () => {
                console.error("Failed to load texture:", url);
                startLoop(); // Start render loop anyway, will use placeholder
            };
            
            image.src = url;
            return texture;
        }

        function createFramebuffer(width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            const renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            return { framebuffer: framebuffer, texture: texture, renderbuffer: renderbuffer };
        }
        
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
    </script>
</body>
</html>
