<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sagittarius A* Simulation (4K WebGL)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .notice {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }
        .notice a {
            color: #8af;
            text-decoration: none;
        }
        #slider {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            z-index: 10;
            accent-color: #f80;
        }
    </style>
</head>
<body>
    <div class="notice">
        This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0).<br>
        Hosted at: <a href="https://jrobb.org/space/sagittarius-a.html" target="_blank">https://jrobb.org/space/sagittarius-a.html</a><br>
        Source: <a href="https://github.com/squalor-xyz/space/blob/main/sagittarius-a.html" target="_blank">https://github.com/squalor-xyz/space/blob/main/sagittarius-a.html</a>
    </div>
    <canvas id="glcanvas"></canvas>
    <input type="range" id="slider" min="0" max="1" step="0.001" value="0">

    <script id="sim-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            v_texCoord = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="sim-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform sampler2D u_tex;
        
        uniform vec2 u_bhPos;
        uniform float u_rs;
        uniform float u_spin;
        uniform float u_strength;

        // Noise functions
        vec2 hash(vec2 p) {
            p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
            return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));
            float b = dot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));
            float c = dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));
            float d = dot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            vec2 shift = vec2(100.0);
            float lacunarity = 2.02;
            // Reduced to 3 octaves for performance
            for (int i = 0; i < 3; ++i) {
                v += a * noise(p);
                p = p * lacunarity + shift;
                a *= 0.5;
            }
            return v;
        }

        void main() {
            vec2 uv = v_texCoord;
            vec2 to_bh = uv - u_bhPos;
            float r = length(to_bh);
            float phi = atan(to_bh.y, to_bh.x);
            float r_norm = r / u_rs;

            // Gravitational Lensing
            vec2 hat_v = to_bh / r;
            float rs2 = u_rs * u_rs;
            vec2 deflection = (r > 0.0) ? hat_v * (rs2 / (r * r)) * u_strength : vec2(0.0);
            vec3 bg = texture2D(u_tex, fract(uv + deflection)).rgb;
            vec3 col = bg;

            // Shadow
            float shadow = 1.0;
            if (r_norm < 1.0) {
                shadow = 0.0;
            } else if (r_norm < 2.0) {
                shadow = 1.0 - 0.9 * (1.0 - smoothstep(1.0, 2.0, r_norm));
            }
            col *= shadow;
            if (r_norm < 1.0) col = vec3(0.0); // Absolute black event horizon

            // Accretion Disk
            float inner = 3.0;
            float outer = 12.0;
            float density = smoothstep(outer, outer - 1.0, r_norm) * (1.0 - smoothstep(inner - 0.5, inner, r_norm));
            density *= exp(-abs(phi) / 0.6); // Equatorial pinch
            float swirl = phi - u_time * 0.15 / sqrt(max(0.1, r_norm)) + u_spin * u_time * 0.4;
            float turb = fbm(vec2(r_norm * 8.0, swirl * 4.0)) * 0.4 + 0.6;
            float pulsing = 0.7 + 0.3 * sin(u_time * 1.5);
            float doppler_disk = 1.0 + 0.4 * u_spin * sin(phi + 1.57); // Reduced Doppler
            
            vec3 disk_col = vec3(1.0, 0.4, 0.0) * pulsing * turb * doppler_disk; // Adjusted color
            disk_col.g = mix(disk_col.g, 1.0, smoothstep(1.0, 1.3, doppler_disk)); // Yellow shift
            disk_col.r = mix(disk_col.r, 0.8, smoothstep(1.0, 0.7, doppler_disk)); // Red shift
            
            float disk_alpha = density * 0.45; // Reduced alpha
            col = mix(col, disk_col, disk_alpha);

            // Photon Ring
            float ring_r = 1.5;
            float dist_ring = abs(r_norm - ring_r);
            float ring = smoothstep(0.015, 0.0, dist_ring) * (1.0 - smoothstep(0.0, 0.03, dist_ring));
            float ring_flicker = fbm(vec2(phi * 20.0 + u_time * 0.05, 0.0)) * 0.3 + 0.7;
            float doppler_ring = 1.0 + 0.3 * u_spin * sin(phi + 1.57); // Reduced Doppler
            vec3 ring_col = vec3(1.0, 0.6, 0.1) * (0.8 + 0.2 * sin(u_time * 0.5)) * ring_flicker * doppler_ring; // Brighter/warmer color
            
            float ring_alpha = ring * 0.7; // Increased alpha
            col = mix(col, ring_col, ring_alpha);
            
            // Re-assert horizon
            if (r_norm < 1.0) col = vec3(0.0);

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script id="blit-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            v_texCoord = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="blit-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_tex;
        void main() {
            gl_FragColor = texture2D(u_tex, v_texCoord);
        }
    </script>

    <script>
        let gl, simProgram, blitProgram, quadBuffer, fbo, bgTexture;
        let u_time, u_resolution, u_tex_sim, u_bhPos, u_rs, u_spin, u_strength;
        let u_tex_blit;
        
        let startTime = performance.now();
        // REDUCED TO 4K FOR PERFORMANCE
        const FBO_WIDTH = 3840;
        const FBO_HEIGHT = 2160;
        const BG_URL = "https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg";

        let slider, useSlider = false, progress = 0;
        const LOOP_DURATION = 300.0;

        function initWebGL(canvas) {
            const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!context) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return null;
            }
            return context;
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createFBO(gl, width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error("Framebuffer object is incomplete: " + gl.checkFramebufferStatus(gl.FRAMEBUFFER));
            }

            return { framebuffer, texture, width, height };
        }

        function loadTexture(gl, url, wrap) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // Fallback: 1x1 black pixel
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

            const image = new Image();
            image.crossOrigin = "anonymous";
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            };
            image.onerror = (e) => {
                console.error("Failed to load texture: " + url, e);
            };
            image.src = url;
            return texture;
        }

        function resize() {
            const canvas = gl.canvas;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr);
            const displayHeight = Math.round(canvas.clientHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }

        function setup() {
            const canvas = document.getElementById('glcanvas');
            gl = initWebGL(canvas);
            if (!gl) return;

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.DEPTH_TEST);

            const simVS = document.getElementById('sim-vertex-shader').textContent;
            const simFS = document.getElementById('sim-fragment-shader').textContent;
            const blitVS = document.getElementById('blit-vertex-shader').textContent;
            const blitFS = document.getElementById('blit-fragment-shader').textContent;

            simProgram = createProgram(gl, simVS, simFS);
            blitProgram = createProgram(gl, blitVS, blitFS);

            quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

            const simPosAttr = gl.getAttribLocation(simProgram, 'a_position');
            gl.enableVertexAttribArray(simPosAttr);
            gl.vertexAttribPointer(simPosAttr, 2, gl.FLOAT, false, 0, 0);
            
            const blitPosAttr = gl.getAttribLocation(blitProgram, 'a_position');
            gl.enableVertexAttribArray(blitPosAttr);
            gl.vertexAttribPointer(blitPosAttr, 2, gl.FLOAT, false, 0, 0);

            fbo = createFBO(gl, FBO_WIDTH, FBO_HEIGHT);
            bgTexture = loadTexture(gl, BG_URL, gl.REPEAT);

            u_time = gl.getUniformLocation(simProgram, "u_time");
            u_resolution = gl.getUniformLocation(simProgram, "u_resolution");
            u_tex_sim = gl.getUniformLocation(simProgram, "u_tex");
            u_bhPos = gl.getUniformLocation(simProgram, "u_bhPos");
            u_rs = gl.getUniformLocation(simProgram, "u_rs");
            u_spin = gl.getUniformLocation(simProgram, "u_spin");
            u_strength = gl.getUniformLocation(simProgram, "u_strength");
            
            u_tex_blit = gl.getUniformLocation(blitProgram, "u_tex");

            slider = document.getElementById("slider");
            slider.oninput = () => { useSlider = true; progress = parseFloat(slider.value); };
            slider.onmouseup = slider.ontouchend = () => { 
                startTime = performance.now() - progress * LOOP_DURATION * 1000.0;
                useSlider = false; 
            };

            window.addEventListener('resize', resize);
            resize();
            animate(performance.now());
        }

        function animate(now) {
            requestAnimationFrame(animate);
            
            let t;
            if (useSlider) {
                t = progress * LOOP_DURATION;
            } else {
                t = (now - startTime) / 1000.0;
                progress = (t / LOOP_DURATION) % 1.0;
                if (slider) slider.value = progress;
            }

            // 1. Render to FBO
            gl.useProgram(simProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            gl.viewport(0, 0, fbo.width, fbo.height);

            gl.uniform1f(u_time, t);
            gl.uniform2f(u_resolution, fbo.width, fbo.height);
            gl.uniform2f(u_bhPos, 0.5, 0.5);
            gl.uniform1f(u_rs, 0.015);
            gl.uniform1f(u_spin, 0.7);
            gl.uniform1f(u_strength, 0.3);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(u_tex_sim, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 2. Blit to Canvas
            gl.useProgram(blitProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.uniform1i(u_tex_blit, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        window.onload = setup;
    </script>
</body>
</html>
