<!--
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.

Hosted at: https://jrobb.org/space/sagittarius-a.html
Source code: https://github.com/squalor-xyz/space/blob/main/sagittarius-a.html
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyper-Realistic 8K Sagittarius A* Black Hole Simulation</title>
    <style>
        html, body {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            padding: 0px;
            margin: 0px;
            overflow: hidden;
            display: flex;
            height: 100%;
            width: 100%;
            background-color: #000;
        }

        canvas {
            margin: auto auto;
        }
    </style>
</head>
<body>
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        #define PI 3.14159265359

        uniform sampler2D u_image;
        varying vec2 v_texCoord;

        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_mass;
        uniform float u_time;

        vec2 rotate(vec2 mt, vec2 st, float angle){
            // For realism, enabling time-based rotation to simulate spinning black hole like Sgr A*
            float cos = cos(angle) * (u_time * 0.3);
            float sin = sin(angle) * (u_time * 0.3);
            
            float nx = (cos * (st.x - mt.x)) + (sin * (st.y - mt.y)) + mt.x;
            float ny = (cos * (st.y - mt.y)) - (sin * (st.x - mt.x)) + mt.y;
            return vec2(nx, ny);
        }

        void main() {
             vec2 st = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y)/u_resolution;
            vec2 mt = vec2(u_mouse.x, u_resolution.y - u_mouse.y)/u_resolution;

            float dx = st.x - mt.x;
            float dy = st.y - mt.y;

            float dist = sqrt(dx * dx + dy * dy);
            float pull = u_mass / (dist * dist);
            
             vec3 color = vec3(0.0);
            
            vec2 r = rotate(mt,st,pull);
            vec4 imgcolor = texture2D(u_image, r);
            color = vec3(
                (imgcolor.x - (pull * 0.25)),
                (imgcolor.y - (pull * 0.25)), 
                (imgcolor.z - (pull * 0.25))
            );
            

             gl_FragColor = vec4(color,1.);
        }
    </script>
    <script id="2d-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0, 1);
            v_texCoord = a_texCoord;
        }
    </script>
    <canvas id="glscreen"></canvas>

    <script>
        // set up global javascript variables

        var bgUrl = 'https://www.quantamagazine.org/wp-content/uploads/2022/05/SAG-A-VIDEO-COVER-1720x968.jpg';

        var blackholeMass = 4000; // Increased mass for stronger lensing, representing Sgr A*'s ~4 million solar masses
        var curblackholeMass = 0;

        var canvas, gl; // canvas and webgl context

        var shaderScript;
        var shaderSource;
        var vertexShader; // Vertex shader
        var fragmentShader; // Fragment shader
        var buffer;

        var locationOfTime;
        var locationOfResolution;
        var locationOfMouse;
        var locationOfMass;

        var startTime = new Date().getTime(); // Get start time for animating
        var currentTime = 0;

        function init(image) {
            canvas = document.getElementById('glscreen');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            // Set to 8K resolution (7680x4320)
            canvas.width  = 7680;
            canvas.height = 4320;

            // Fixed position at center
            var mouse = {x: canvas.width / 2, y: canvas.height / 2};

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(
                gl.ARRAY_BUFFER, 
                new Float32Array([
                    -1.0, -1.0, 
                    1.0, -1.0, 
                    -1.0,  1.0, 
                    -1.0,  1.0, 
                    1.0, -1.0, 
                    1.0,  1.0]), 
                gl.STATIC_DRAW
            );

            shaderScript = document.getElementById("2d-vertex-shader");
            shaderSource = shaderScript.text;
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, shaderSource);
            gl.compileShader(vertexShader);

            shaderScript   = document.getElementById("2d-fragment-shader");
            shaderSource   = shaderScript.text;
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, shaderSource);
            gl.compileShader(fragmentShader);

            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            locationOfResolution = gl.getUniformLocation(program, "u_resolution");
            locationOfMouse = gl.getUniformLocation(program, "u_mouse");
            locationOfMass = gl.getUniformLocation(program, "u_mass");
            locationOfTime = gl.getUniformLocation(program, "u_time");

            gl.uniform2f(locationOfResolution, canvas.width, canvas.height);
            gl.uniform2f(locationOfMouse, mouse.x, mouse.y);
            gl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            gl.uniform1f(locationOfTime, currentTime);

            var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

            var texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1.0, -1.0, 
                1.0, -1.0, 
                -1.0,  1.0, 
                -1.0,  1.0, 
                1.0, -1.0, 
                1.0,  1.0]), 
                gl.STATIC_DRAW);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            render();
        }

        function render() {
            var now = new Date().getTime();
            currentTime = (now - startTime) / 1000;

            if(curblackholeMass < blackholeMass - 50){
                curblackholeMass += (blackholeMass-curblackholeMass) * 0.03;
            }

            gl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            gl.uniform1f(locationOfTime, currentTime);

            window.requestAnimationFrame(render, canvas);

            positionLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        window.addEventListener('load', function(event){
            var image = new Image();
            image.crossOrigin = "Anonymous";
            image.src = bgUrl;
            image.onload = function() {
                init(image);
            }
        });

        window.addEventListener('resize', function(event){
            canvas.width  = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            locationOfResolution = gl.getUniformLocation(program, "u_resolution");
            gl.uniform2f(locationOfResolution, canvas.width, canvas.height);
        });
    </script>
</body>
</html>
