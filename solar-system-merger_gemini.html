<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar System Merger Visualization (8K WebGL)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .notice {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }
        .notice a {
            color: #8af;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="notice">
        This simulation is licensed under the Mozilla Public License 2.0 (MPL-2.0).<br>
        Hosted at: <a href="https://jrobb.org/space/solar-system-merger.html" target="_blank">https://jrobb.org/space/solar-system-merger.html</a><br>
        Source: <a href="https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html" target="_blank">https://github.com/squalor-xyz/space/blob/main/solar-system-merger.html</a>
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="sim-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            v_texCoord = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="sim-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform sampler2D u_tex;
        
        uniform vec2 u_mwPos;
        uniform vec2 u_andPos;
        uniform float u_prog;

        float hash1(float n) { 
            return fract(sin(n) * 43758.5453); 
        }
        
        vec2 hash2(float n) { 
            return fract(sin(vec2(n, n + 1.0)) * vec2(43758.5453, 21758.5453)); 
        }

        float draw_dot(vec2 uv, vec2 pos, float size) {
            float dist = length((uv - pos) * vec2(u_resolution.y / u_resolution.x, 1.0));
            return smoothstep(size * 0.5, 0.0, dist);
        }

        float draw_star(vec2 uv, vec2 pos, float size, float brightness) {
            float dist = length((uv - pos) * vec2(u_resolution.y / u_resolution.x, 1.0));
            return smoothstep(size, 0.0, dist) * brightness;
        }

        void main() {
            vec2 uv = v_texCoord;
            vec3 col = texture2D(u_tex, uv).rgb * 0.8; // Dim background slightly

            float t_slow = u_time * 0.001;
            float t_orbit = u_time * 0.0005;
            float aspect = u_resolution.x / u_resolution.y;

            // Milky Way Stars
            for (float i = 0.0; i < 100.0; i++) {
                vec2 offset = (hash2(i) - 0.5) * 0.4; // 0.2 radius
                offset *= (1.0 + sin(t_slow + i) * 0.05); // Pulsing
                vec2 star_pos = u_mwPos + offset;
                float brightness = 0.5 + 0.5 * hash1(i + 100.0);
                col += vec3(1.0, 1.0, 0.9) * draw_star(uv, star_pos, 0.001, brightness);
            }

            // Andromeda Stars (fade out at merge)
            if (u_prog <= 0.85) {
                float and_alpha = smoothstep(0.85, 0.8, u_prog);
                for (float i = 0.0; i < 100.0; i++) {
                    vec2 offset = (hash2(i + 200.0) - 0.5) * 0.4;
                    offset *= (1.0 + sin(t_slow + i + 50.0) * 0.05);
                    vec2 star_pos = u_andPos + offset;
                    float brightness = 0.5 + 0.5 * hash1(i + 300.0);
                    col += vec3(0.9, 1.0, 1.0) * draw_star(uv, star_pos, 0.001, brightness) * and_alpha;
                }
            }
            
            // Our Solar System (Yellow)
            vec2 ss_mw_pos = u_mwPos + vec2(0.1 * sin(t_orbit), 0.1 * cos(t_orbit) / aspect);
            col += vec3(1.0, 1.0, 0.0) * draw_dot(uv, ss_mw_pos, 0.005);

            // Andromeda Sample System (Cyan)
            if (u_prog <= 0.85) {
                float and_alpha = smoothstep(0.85, 0.8, u_prog);
                vec2 ss_and_pos = u_andPos + vec2(0.1 * cos(t_orbit), 0.1 * sin(t_orbit) / aspect);
                col += vec3(0.0, 1.0, 1.0) * draw_dot(uv, ss_and_pos, 0.005) * and_alpha;
            }

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script id="blit-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            v_texCoord = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="blit-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_tex;
        void main() {
            gl_FragColor = texture2D(u_tex, v_texCoord);
        }
    </script>

    <script>
        let gl, simProgram, blitProgram, quadBuffer, fbo, bgTexture;
        let u_time, u_resolution, u_tex_sim, u_mwPos, u_andPos, u_prog;
        let u_tex_blit;
        
        let startTime = performance.now();
        const FBO_WIDTH = 7680;
        const FBO_HEIGHT = 4320;
        const BG_URL = "https://svs.gsfc.nasa.gov/vis/a000000/a004800/a004851/starmap_2020_4k_print.jpg";

        const PI = 3.1415926535;
        const LOOP_DURATION = 300.0;
        const MERGE_TIME = 0.8;

        function initWebGL(canvas) {
            const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!context) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return null;
            }
            return context;
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function createFBO(gl, width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error("Framebuffer object is incomplete: " + gl.checkFramebufferStatus(gl.FRAMEBUFFER));
            }

            return { framebuffer, texture, width, height };
        }

        function loadTexture(gl, url, wrap) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

            const image = new Image();
            image.crossOrigin = "anonymous";
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            };
            image.onerror = (e) => {
                console.error("Failed to load texture: " + url, e);
            };
            image.src = url;
            return texture;
        }

        function resize() {
            const canvas = gl.canvas;
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr);
            const displayHeight = Math.round(canvas.clientHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }

        function setup() {
            const canvas = document.getElementById('glcanvas');
            gl = initWebGL(canvas);
            if (!gl) return;

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.DEPTH_TEST);

            const simVS = document.getElementById('sim-vertex-shader').textContent;
            const simFS = document.getElementById('sim-fragment-shader').textContent;
            const blitVS = document.getElementById('blit-vertex-shader').textContent;
            const blitFS = document.getElementById('blit-fragment-shader').textContent;

            simProgram = createProgram(gl, simVS, simFS);
            blitProgram = createProgram(gl, blitVS, blitFS);

            quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

            const simPosAttr = gl.getAttribLocation(simProgram, 'a_position');
            gl.enableVertexAttribArray(simPosAttr);
            gl.vertexAttribPointer(simPosAttr, 2, gl.FLOAT, false, 0, 0);
            
            const blitPosAttr = gl.getAttribLocation(blitProgram, 'a_position');
            gl.enableVertexAttribArray(blitPosAttr);
            gl.vertexAttribPointer(blitPosAttr, 2, gl.FLOAT, false, 0, 0);

            fbo = createFBO(gl, FBO_WIDTH, FBO_HEIGHT);
            bgTexture = loadTexture(gl, BG_URL, gl.CLAMP_TO_EDGE);

            u_time = gl.getUniformLocation(simProgram, "u_time");
            u_resolution = gl.getUniformLocation(simProgram, "u_resolution");
            u_tex_sim = gl.getUniformLocation(simProgram, "u_tex");
            u_mwPos = gl.getUniformLocation(simProgram, "u_mwPos");
            u_andPos = gl.getUniformLocation(simProgram, "u_andPos");
            u_prog = gl.getUniformLocation(simProgram, "u_prog");
            
            u_tex_blit = gl.getUniformLocation(blitProgram, "u_tex");
            
            window.addEventListener('resize', resize);
            resize();
            animate();
        }

        function animate(now) {
            requestAnimationFrame(animate);
            
            const t = (now - startTime) / 1000.0;
            const prog = (t / LOOP_DURATION) % 1.0;

            const amp = 0.4 * (1.0 - prog);
            const theta = prog * 10.0 * PI;
            
            let mwPos = [0.5 + amp * Math.cos(theta), 0.5 + amp * Math.sin(theta)];
            let andPos = [0.5 - amp * Math.cos(theta), 0.5 - amp * Math.sin(theta)];

            if (prog > MERGE_TIME) {
                andPos = mwPos;
            }

            // 1. Render to FBO
            gl.useProgram(simProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            gl.viewport(0, 0, fbo.width, fbo.height);

            gl.uniform1f(u_time, t);
            gl.uniform2f(u_resolution, fbo.width, fbo.height);
            gl.uniform1f(u_prog, prog);
            gl.uniform2f(u_mwPos, mwPos[0], mwPos[1]);
            gl.uniform2f(u_andPos, andPos[0], andPos[1]);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, bgTexture);
            gl.uniform1i(u_tex_sim, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 2. Blit to Canvas
            gl.useProgram(blitProgram);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.uniform1i(u_tex_blit, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        window.onload = setup;
    </script>
</body>
</html>
